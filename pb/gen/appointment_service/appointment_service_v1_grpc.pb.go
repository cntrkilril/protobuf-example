// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.12
// source: appointment_service_v1.proto

package appointment_service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AppointmentServiceV1_CreateAppointment_FullMethodName        = "/appointment.AppointmentServiceV1/CreateAppointment"
	AppointmentServiceV1_CancelAppointment_FullMethodName        = "/appointment.AppointmentServiceV1/CancelAppointment"
	AppointmentServiceV1_ConfirmAppointment_FullMethodName       = "/appointment.AppointmentServiceV1/ConfirmAppointment"
	AppointmentServiceV1_GetAppointmentByMasterID_FullMethodName = "/appointment.AppointmentServiceV1/GetAppointmentByMasterID"
	AppointmentServiceV1_GetAppointmentByClientID_FullMethodName = "/appointment.AppointmentServiceV1/GetAppointmentByClientID"
)

// AppointmentServiceV1Client is the client API for AppointmentServiceV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppointmentServiceV1Client interface {
	CreateAppointment(ctx context.Context, in *CreateAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error)
	CancelAppointment(ctx context.Context, in *CancelAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error)
	ConfirmAppointment(ctx context.Context, in *ConfirmAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error)
	GetAppointmentByMasterID(ctx context.Context, in *GetAppointmentByMasterIDRequestV1, opts ...grpc.CallOption) (*GetAppointmentByMasterIDResponseV1, error)
	GetAppointmentByClientID(ctx context.Context, in *GetAppointmentByClientIDRequestV1, opts ...grpc.CallOption) (*GetAppointmentByClientIDResponseV1, error)
}

type appointmentServiceV1Client struct {
	cc grpc.ClientConnInterface
}

func NewAppointmentServiceV1Client(cc grpc.ClientConnInterface) AppointmentServiceV1Client {
	return &appointmentServiceV1Client{cc}
}

func (c *appointmentServiceV1Client) CreateAppointment(ctx context.Context, in *CreateAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error) {
	out := new(AppointmentEntityV1)
	err := c.cc.Invoke(ctx, AppointmentServiceV1_CreateAppointment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appointmentServiceV1Client) CancelAppointment(ctx context.Context, in *CancelAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error) {
	out := new(AppointmentEntityV1)
	err := c.cc.Invoke(ctx, AppointmentServiceV1_CancelAppointment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appointmentServiceV1Client) ConfirmAppointment(ctx context.Context, in *ConfirmAppointmentRequestV1, opts ...grpc.CallOption) (*AppointmentEntityV1, error) {
	out := new(AppointmentEntityV1)
	err := c.cc.Invoke(ctx, AppointmentServiceV1_ConfirmAppointment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appointmentServiceV1Client) GetAppointmentByMasterID(ctx context.Context, in *GetAppointmentByMasterIDRequestV1, opts ...grpc.CallOption) (*GetAppointmentByMasterIDResponseV1, error) {
	out := new(GetAppointmentByMasterIDResponseV1)
	err := c.cc.Invoke(ctx, AppointmentServiceV1_GetAppointmentByMasterID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appointmentServiceV1Client) GetAppointmentByClientID(ctx context.Context, in *GetAppointmentByClientIDRequestV1, opts ...grpc.CallOption) (*GetAppointmentByClientIDResponseV1, error) {
	out := new(GetAppointmentByClientIDResponseV1)
	err := c.cc.Invoke(ctx, AppointmentServiceV1_GetAppointmentByClientID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppointmentServiceV1Server is the server API for AppointmentServiceV1 service.
// All implementations must embed UnimplementedAppointmentServiceV1Server
// for forward compatibility
type AppointmentServiceV1Server interface {
	CreateAppointment(context.Context, *CreateAppointmentRequestV1) (*AppointmentEntityV1, error)
	CancelAppointment(context.Context, *CancelAppointmentRequestV1) (*AppointmentEntityV1, error)
	ConfirmAppointment(context.Context, *ConfirmAppointmentRequestV1) (*AppointmentEntityV1, error)
	GetAppointmentByMasterID(context.Context, *GetAppointmentByMasterIDRequestV1) (*GetAppointmentByMasterIDResponseV1, error)
	GetAppointmentByClientID(context.Context, *GetAppointmentByClientIDRequestV1) (*GetAppointmentByClientIDResponseV1, error)
	mustEmbedUnimplementedAppointmentServiceV1Server()
}

// UnimplementedAppointmentServiceV1Server must be embedded to have forward compatible implementations.
type UnimplementedAppointmentServiceV1Server struct {
}

func (UnimplementedAppointmentServiceV1Server) CreateAppointment(context.Context, *CreateAppointmentRequestV1) (*AppointmentEntityV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppointment not implemented")
}
func (UnimplementedAppointmentServiceV1Server) CancelAppointment(context.Context, *CancelAppointmentRequestV1) (*AppointmentEntityV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelAppointment not implemented")
}
func (UnimplementedAppointmentServiceV1Server) ConfirmAppointment(context.Context, *ConfirmAppointmentRequestV1) (*AppointmentEntityV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmAppointment not implemented")
}
func (UnimplementedAppointmentServiceV1Server) GetAppointmentByMasterID(context.Context, *GetAppointmentByMasterIDRequestV1) (*GetAppointmentByMasterIDResponseV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppointmentByMasterID not implemented")
}
func (UnimplementedAppointmentServiceV1Server) GetAppointmentByClientID(context.Context, *GetAppointmentByClientIDRequestV1) (*GetAppointmentByClientIDResponseV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAppointmentByClientID not implemented")
}
func (UnimplementedAppointmentServiceV1Server) mustEmbedUnimplementedAppointmentServiceV1Server() {}

// UnsafeAppointmentServiceV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppointmentServiceV1Server will
// result in compilation errors.
type UnsafeAppointmentServiceV1Server interface {
	mustEmbedUnimplementedAppointmentServiceV1Server()
}

func RegisterAppointmentServiceV1Server(s grpc.ServiceRegistrar, srv AppointmentServiceV1Server) {
	s.RegisterService(&AppointmentServiceV1_ServiceDesc, srv)
}

func _AppointmentServiceV1_CreateAppointment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppointmentRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppointmentServiceV1Server).CreateAppointment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppointmentServiceV1_CreateAppointment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppointmentServiceV1Server).CreateAppointment(ctx, req.(*CreateAppointmentRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppointmentServiceV1_CancelAppointment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelAppointmentRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppointmentServiceV1Server).CancelAppointment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppointmentServiceV1_CancelAppointment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppointmentServiceV1Server).CancelAppointment(ctx, req.(*CancelAppointmentRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppointmentServiceV1_ConfirmAppointment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmAppointmentRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppointmentServiceV1Server).ConfirmAppointment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppointmentServiceV1_ConfirmAppointment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppointmentServiceV1Server).ConfirmAppointment(ctx, req.(*ConfirmAppointmentRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppointmentServiceV1_GetAppointmentByMasterID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppointmentByMasterIDRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppointmentServiceV1Server).GetAppointmentByMasterID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppointmentServiceV1_GetAppointmentByMasterID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppointmentServiceV1Server).GetAppointmentByMasterID(ctx, req.(*GetAppointmentByMasterIDRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppointmentServiceV1_GetAppointmentByClientID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppointmentByClientIDRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppointmentServiceV1Server).GetAppointmentByClientID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppointmentServiceV1_GetAppointmentByClientID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppointmentServiceV1Server).GetAppointmentByClientID(ctx, req.(*GetAppointmentByClientIDRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

// AppointmentServiceV1_ServiceDesc is the grpc.ServiceDesc for AppointmentServiceV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppointmentServiceV1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "appointment.AppointmentServiceV1",
	HandlerType: (*AppointmentServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAppointment",
			Handler:    _AppointmentServiceV1_CreateAppointment_Handler,
		},
		{
			MethodName: "CancelAppointment",
			Handler:    _AppointmentServiceV1_CancelAppointment_Handler,
		},
		{
			MethodName: "ConfirmAppointment",
			Handler:    _AppointmentServiceV1_ConfirmAppointment_Handler,
		},
		{
			MethodName: "GetAppointmentByMasterID",
			Handler:    _AppointmentServiceV1_GetAppointmentByMasterID_Handler,
		},
		{
			MethodName: "GetAppointmentByClientID",
			Handler:    _AppointmentServiceV1_GetAppointmentByClientID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "appointment_service_v1.proto",
}

const (
	TimeCellServiceV1_GetAvailableTimeByServiceIDAndDate_FullMethodName = "/appointment.TimeCellServiceV1/GetAvailableTimeByServiceIDAndDate"
)

// TimeCellServiceV1Client is the client API for TimeCellServiceV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TimeCellServiceV1Client interface {
	GetAvailableTimeByServiceIDAndDate(ctx context.Context, in *GetAvailableTimeByServiceIDAndDateRequestV1, opts ...grpc.CallOption) (*GetAvailableTimeByServiceIDAndDateResponseV1, error)
}

type timeCellServiceV1Client struct {
	cc grpc.ClientConnInterface
}

func NewTimeCellServiceV1Client(cc grpc.ClientConnInterface) TimeCellServiceV1Client {
	return &timeCellServiceV1Client{cc}
}

func (c *timeCellServiceV1Client) GetAvailableTimeByServiceIDAndDate(ctx context.Context, in *GetAvailableTimeByServiceIDAndDateRequestV1, opts ...grpc.CallOption) (*GetAvailableTimeByServiceIDAndDateResponseV1, error) {
	out := new(GetAvailableTimeByServiceIDAndDateResponseV1)
	err := c.cc.Invoke(ctx, TimeCellServiceV1_GetAvailableTimeByServiceIDAndDate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TimeCellServiceV1Server is the server API for TimeCellServiceV1 service.
// All implementations must embed UnimplementedTimeCellServiceV1Server
// for forward compatibility
type TimeCellServiceV1Server interface {
	GetAvailableTimeByServiceIDAndDate(context.Context, *GetAvailableTimeByServiceIDAndDateRequestV1) (*GetAvailableTimeByServiceIDAndDateResponseV1, error)
	mustEmbedUnimplementedTimeCellServiceV1Server()
}

// UnimplementedTimeCellServiceV1Server must be embedded to have forward compatible implementations.
type UnimplementedTimeCellServiceV1Server struct {
}

func (UnimplementedTimeCellServiceV1Server) GetAvailableTimeByServiceIDAndDate(context.Context, *GetAvailableTimeByServiceIDAndDateRequestV1) (*GetAvailableTimeByServiceIDAndDateResponseV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableTimeByServiceIDAndDate not implemented")
}
func (UnimplementedTimeCellServiceV1Server) mustEmbedUnimplementedTimeCellServiceV1Server() {}

// UnsafeTimeCellServiceV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimeCellServiceV1Server will
// result in compilation errors.
type UnsafeTimeCellServiceV1Server interface {
	mustEmbedUnimplementedTimeCellServiceV1Server()
}

func RegisterTimeCellServiceV1Server(s grpc.ServiceRegistrar, srv TimeCellServiceV1Server) {
	s.RegisterService(&TimeCellServiceV1_ServiceDesc, srv)
}

func _TimeCellServiceV1_GetAvailableTimeByServiceIDAndDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableTimeByServiceIDAndDateRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimeCellServiceV1Server).GetAvailableTimeByServiceIDAndDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimeCellServiceV1_GetAvailableTimeByServiceIDAndDate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimeCellServiceV1Server).GetAvailableTimeByServiceIDAndDate(ctx, req.(*GetAvailableTimeByServiceIDAndDateRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

// TimeCellServiceV1_ServiceDesc is the grpc.ServiceDesc for TimeCellServiceV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimeCellServiceV1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "appointment.TimeCellServiceV1",
	HandlerType: (*TimeCellServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAvailableTimeByServiceIDAndDate",
			Handler:    _TimeCellServiceV1_GetAvailableTimeByServiceIDAndDate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "appointment_service_v1.proto",
}

const (
	WorkTimeServiceV1_GetWorkTimeByMasterID_FullMethodName = "/appointment.WorkTimeServiceV1/GetWorkTimeByMasterID"
	WorkTimeServiceV1_UpdateWorkTime_FullMethodName        = "/appointment.WorkTimeServiceV1/UpdateWorkTime"
	WorkTimeServiceV1_DeleteWorkTime_FullMethodName        = "/appointment.WorkTimeServiceV1/DeleteWorkTime"
)

// WorkTimeServiceV1Client is the client API for WorkTimeServiceV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkTimeServiceV1Client interface {
	GetWorkTimeByMasterID(ctx context.Context, in *GetWorkTimeByMasterIDRequestV1, opts ...grpc.CallOption) (*GetWorkTimeByMasterIDResponseV1, error)
	UpdateWorkTime(ctx context.Context, in *UpdateWorkTimeRequestV1, opts ...grpc.CallOption) (*WorkTimeEntityV1, error)
	DeleteWorkTime(ctx context.Context, in *DeleteWorkTimeRequestV1, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type workTimeServiceV1Client struct {
	cc grpc.ClientConnInterface
}

func NewWorkTimeServiceV1Client(cc grpc.ClientConnInterface) WorkTimeServiceV1Client {
	return &workTimeServiceV1Client{cc}
}

func (c *workTimeServiceV1Client) GetWorkTimeByMasterID(ctx context.Context, in *GetWorkTimeByMasterIDRequestV1, opts ...grpc.CallOption) (*GetWorkTimeByMasterIDResponseV1, error) {
	out := new(GetWorkTimeByMasterIDResponseV1)
	err := c.cc.Invoke(ctx, WorkTimeServiceV1_GetWorkTimeByMasterID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workTimeServiceV1Client) UpdateWorkTime(ctx context.Context, in *UpdateWorkTimeRequestV1, opts ...grpc.CallOption) (*WorkTimeEntityV1, error) {
	out := new(WorkTimeEntityV1)
	err := c.cc.Invoke(ctx, WorkTimeServiceV1_UpdateWorkTime_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workTimeServiceV1Client) DeleteWorkTime(ctx context.Context, in *DeleteWorkTimeRequestV1, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkTimeServiceV1_DeleteWorkTime_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkTimeServiceV1Server is the server API for WorkTimeServiceV1 service.
// All implementations must embed UnimplementedWorkTimeServiceV1Server
// for forward compatibility
type WorkTimeServiceV1Server interface {
	GetWorkTimeByMasterID(context.Context, *GetWorkTimeByMasterIDRequestV1) (*GetWorkTimeByMasterIDResponseV1, error)
	UpdateWorkTime(context.Context, *UpdateWorkTimeRequestV1) (*WorkTimeEntityV1, error)
	DeleteWorkTime(context.Context, *DeleteWorkTimeRequestV1) (*emptypb.Empty, error)
	mustEmbedUnimplementedWorkTimeServiceV1Server()
}

// UnimplementedWorkTimeServiceV1Server must be embedded to have forward compatible implementations.
type UnimplementedWorkTimeServiceV1Server struct {
}

func (UnimplementedWorkTimeServiceV1Server) GetWorkTimeByMasterID(context.Context, *GetWorkTimeByMasterIDRequestV1) (*GetWorkTimeByMasterIDResponseV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkTimeByMasterID not implemented")
}
func (UnimplementedWorkTimeServiceV1Server) UpdateWorkTime(context.Context, *UpdateWorkTimeRequestV1) (*WorkTimeEntityV1, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWorkTime not implemented")
}
func (UnimplementedWorkTimeServiceV1Server) DeleteWorkTime(context.Context, *DeleteWorkTimeRequestV1) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkTime not implemented")
}
func (UnimplementedWorkTimeServiceV1Server) mustEmbedUnimplementedWorkTimeServiceV1Server() {}

// UnsafeWorkTimeServiceV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkTimeServiceV1Server will
// result in compilation errors.
type UnsafeWorkTimeServiceV1Server interface {
	mustEmbedUnimplementedWorkTimeServiceV1Server()
}

func RegisterWorkTimeServiceV1Server(s grpc.ServiceRegistrar, srv WorkTimeServiceV1Server) {
	s.RegisterService(&WorkTimeServiceV1_ServiceDesc, srv)
}

func _WorkTimeServiceV1_GetWorkTimeByMasterID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkTimeByMasterIDRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkTimeServiceV1Server).GetWorkTimeByMasterID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkTimeServiceV1_GetWorkTimeByMasterID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkTimeServiceV1Server).GetWorkTimeByMasterID(ctx, req.(*GetWorkTimeByMasterIDRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkTimeServiceV1_UpdateWorkTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkTimeRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkTimeServiceV1Server).UpdateWorkTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkTimeServiceV1_UpdateWorkTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkTimeServiceV1Server).UpdateWorkTime(ctx, req.(*UpdateWorkTimeRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkTimeServiceV1_DeleteWorkTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkTimeRequestV1)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkTimeServiceV1Server).DeleteWorkTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkTimeServiceV1_DeleteWorkTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkTimeServiceV1Server).DeleteWorkTime(ctx, req.(*DeleteWorkTimeRequestV1))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkTimeServiceV1_ServiceDesc is the grpc.ServiceDesc for WorkTimeServiceV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkTimeServiceV1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "appointment.WorkTimeServiceV1",
	HandlerType: (*WorkTimeServiceV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkTimeByMasterID",
			Handler:    _WorkTimeServiceV1_GetWorkTimeByMasterID_Handler,
		},
		{
			MethodName: "UpdateWorkTime",
			Handler:    _WorkTimeServiceV1_UpdateWorkTime_Handler,
		},
		{
			MethodName: "DeleteWorkTime",
			Handler:    _WorkTimeServiceV1_DeleteWorkTime_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "appointment_service_v1.proto",
}
